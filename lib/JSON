#DEFINE JSON
-- JSON4Lua: JSON encoding / decoding support for the Lua language.
-- JSON Library.
-- Author: Craig Mason-Jones
-- Homepage: http://json.luaforge.net/
-- Version: 0.9.40
-- This library is released under the MIT License (MIT).
-- Please see LICENCE for details.
-- Modified by skwerlman on 6/15/14 to work as a library under CLua
local JSON={} JSON.Local={}
function JSON.Local.decode_scanArray(s,startPos) local array={} local stringLen=string.len(s) assert(string.sub(s,startPos,startPos)=='[','decode_scanArray called but array does not start at position '..startPos..' in string:\n'..s) startPos=startPos+1 repeat startPos=JSON.Local.decode_scanWhitespace(s,startPos) assert(startPos<=stringLen,'JSON String ended unexpectedly scanning array.') local curChar=string.sub(s,startPos,startPos) if (curChar==']') then return array,startPos+1 end if (curChar==',') then startPos=JSON.Local.decode_scanWhitespace(s,startPos+1) end assert(startPos<=stringLen,'JSON String ended unexpectedly scanning array.') object,startPos=JSON.decode(s,startPos) table.insert(array,object) until false end
function JSON.Local.decode_scanComment(s,startPos) assert(string.sub(s,startPos,startPos+1)=='/*',"decode_scanComment called but comment does not start at position "..startPos) local endPos=string.find(s,'*/',startPos+2) assert(endPos~=nil,"Unterminated comment in string at "..startPos) return endPos+2 end
function JSON.Local.decode_scanConstant(s,startPos) local consts={["true"]=true,["false"]=false,["null"]=nil} local constNames={"true","false","null"} for i,k in pairs(constNames) do if string.sub(s,startPos,startPos+string.len(k) -1)==k then return consts[k],startPos+string.len(k) end end assert(nil,'Failed to scan constant from string '..s..' at starting position '..startPos) end
function JSON.Local.decode_scanNumber(s,startPos) local endPos=startPos+1 local stringLen=string.len(s) local acceptableChars="+-0123456789.e" while (string.find(acceptableChars,string.sub(s,endPos,endPos),1,true) and endPos<=stringLen) do endPos=endPos+1 end local stringValue='return '..string.sub(s,startPos,endPos-1) local stringEval=loadstring(stringValue) assert(stringEval,'Failed to scan number [ '..stringValue..'] in JSON string at position '..startPos..' : '..endPos) return stringEval(),endPos end
function JSON.Local.decode_scanObject(s,startPos) local object={} local stringLen=string.len(s) local key,value assert(string.sub(s,startPos,startPos)=='{','decode_scanObject called but object does not start at position '..startPos..' in string:\n'..s) startPos=startPos+1 repeat startPos=JSON.Local.decode_scanWhitespace(s,startPos) assert(startPos<=stringLen,'JSON string ended unexpectedly while scanning object.') local curChar=string.sub(s,startPos,startPos) if (curChar=='}') then return object,startPos+1 end if (curChar==',') then startPos=JSON.Local.decode_scanWhitespace(s,startPos+1) end assert(startPos<=stringLen,'JSON string ended unexpectedly scanning object.') key,startPos=JSON.decode(s,startPos) assert(startPos<=stringLen,'JSON string ended unexpectedly searching for value of key '..key) startPos=JSON.Local.decode_scanWhitespace(s,startPos) assert(startPos<=stringLen,'JSON string ended unexpectedly searching for value of key '..key) assert(string.sub(s,startPos,startPos)==':','JSON object key-value assignment mal-formed at '..startPos) startPos=JSON.Local.decode_scanWhitespace(s,startPos+1) assert(startPos<=stringLen,'JSON string ended unexpectedly searching for value of key '..key) value,startPos=JSON.decode(s,startPos) object[key]=value until false end
function JSON.Local.decode_scanString(s,startPos) assert(startPos,'decode_scanString(..) called without start position') local startChar=string.sub(s,startPos,startPos) assert(startChar==[[']] or startChar==[["]],'decode_scanString called for a non-string') local escaped=false local endPos=startPos+1 local bEnded=false local stringLen=string.len(s) repeat local curChar=string.sub(s,endPos,endPos) if not escaped then if curChar==[[\]] then escaped=true else bEnded=curChar==startChar end else escaped=false end endPos=endPos+1 assert(endPos<=stringLen+1,"String decoding failed: unterminated string at position "..endPos) until bEnded local stringValue='return '..string.sub(s,startPos,endPos-1) local stringEval=loadstring(stringValue) assert(stringEval,'Failed to load string [ '..stringValue..'] in JSON4Lua.decode_scanString at position '..startPos..' : '..endPos) return stringEval(),endPos end
function JSON.Local.decode_scanWhitespace(s,startPos) local whitespace=" \n\r\t" local stringLen=string.len(s) while (string.find(whitespace,string.sub(s,startPos,startPos),1,true) and startPos<=stringLen) do startPos=startPos+1 end return startPos end
function JSON.Local.encodeString(s) s=string.gsub(s,'\\','\\\\') s=string.gsub(s,'"','\\"') s=string.gsub(s,"'","\\'") s=string.gsub(s,'\n','\\n') s=string.gsub(s,'\t','\\t') return s end
function JSON.Local.isArray(t) local maxIndex=0 for k,v in pairs(t) do if (type(k)=='number' and math.floor(k)==k and 1<=k) then if (not JSON.Local.isEncodable(v)) then return false end maxIndex=math.max(maxIndex,k) else if (k=='n') then if v~=table.getn(t) then return false end else if JSON.Local.isEncodable(v) then return false end end end end return true,maxIndex end
function JSON.Local.isEncodable(o) local t=type(o) return (t=='string' or t=='boolean' or t=='number' or t=='nil' or t=='table') or (t=='function' and o==null) end
function JSON.encode (v) if v==nil then return "null" end local vtype=type(v) if vtype=='string' then return '"'..JSON.Local.encodeString(v)..'"' end if vtype=='number' or vtype=='boolean' then return tostring(v) end if vtype=='table' then local rval={} local bArray,maxCount=JSON.Local.isArray(v) if bArray then for i=1,maxCount do table.insert(rval,JSON.encode(v[i])) end else for i,j in pairs(v) do if JSON.Local.isEncodable(i) and JSON.Local.isEncodable(j) then table.insert(rval,'"'..JSON.Local.encodeString(i)..'":' ..JSON.encode(j)) end end end if bArray then return '['..table.concat(rval,',') ..']' else return '{'..table.concat(rval,',')..'}' end end if vtype=='function' and v==null then return 'null' end assert(false,'encode attempt to encode unsupported type '..vtype..':'..tostring(v)) end
function JSON.decode(s,startPos) startPos=startPos and startPos or 1 startPos=JSON.Local.decode_scanWhitespace(s,startPos) assert(startPos<=string.len(s),'Unterminated JSON encoded object found at position in ['..s..']') local curChar=string.sub(s,startPos,startPos) if curChar=='{' then return JSON.Local.decode_scanObject(s,startPos) end if curChar=='[' then return JSON.Local.decode_scanArray(s,startPos) end if string.find("+-0123456789.e",curChar,1,true) then return JSON.Local.decode_scanNumber(s,startPos) end if curChar==[["]] or curChar==[[']] then return JSON.Local.decode_scanString(s,startPos) end if string.sub(s,startPos,startPos+1)=='/*' then return JSON.decode(s,JSON.Local.decode_scanComment(s,startPos)) end return JSON.Local.decode_scanConstant(s,startPos) end
function JSON.null() return null end
function JSON.readJSON(loc) local h=fs.open(loc,'r') local o=h.readAll() h.close() return JSON.decode(o) end
function JSON.writeJSON(loc,data) local h=fs.open(loc,'w') h.write(JSON.encode(data)) h.close() end
--END JSON4LUA
